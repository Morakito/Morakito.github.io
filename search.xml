<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>条款01：视C++为一个语言联邦</title>
    <url>/2020/05/Effective-C++/Effective-CPP-01/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天的C++已经是个多重泛型编程语言，支持面向过程、面向对象、函数编程、泛型、元编程等。可以将C++看成一个由相关语言组成的联邦而非单一语言。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>1，C++以C语言为基础，区块（blocks）、语句（statements）、预处理器（preprocesser）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等都来自于C语言。<br>2，但是C语言没有模板（templates），没有异常（exceptions），没有重载（overloading）等概念。</p>
<h4 id="Object——Oriented-C"><a href="#Object——Oriented-C" class="headerlink" title="Object——Oriented C++"></a>Object——Oriented C++</h4><p>即C++的面向对象部分，C with Classes的诉求：类（classes）、封装（encapsulation）、继承（inheritance）、多态（polymorphism）、虚函数（virtual动态绑定）。</p>
<h4 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h4><p>C++的泛型编程部分。带来了新的编程范型，template metaprogramming（TMP，模板元编程）</p>
<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><p>STL是标准模板库，template库。内置容器（containers）、迭代器（iterators）、算法（algorithm）、函数对象（function objects）</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款02：尽量以const，enum，inline替换#define</title>
    <url>/2020/05/Effective-C++/Effective-CPP-02/</url>
    <content><![CDATA[<p><strong>用编译器替换预处理器</strong></p>
<h4 id="define的问题：定义常量"><a href="#define的问题：定义常量" class="headerlink" title="define的问题：定义常量"></a>define的问题：定义常量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>1，难以追踪异常<br>2，无法限制作用域，不提供封装性</p>
<p>解决办法是：<strong>用const常量替代宏（#define）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>；</span><br></pre></td></tr></table></figure>
<p>(ps：大写名称通常用于宏)</p>
<h5 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h5><h6 id="定义常量指针"><a href="#定义常量指针" class="headerlink" title="定义常量指针"></a>定义常量指针</h6><p>常量定义通常被定义在头文件中，有必要将指针（而不是指针所指之物）声名为const<br>例如定义一个常量字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Scott Meyers"</span>;</span><br></pre></td></tr></table></figure>
<p>一种更好的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"Scott Meyers"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="定义class专属常量（限制作用域）"><a href="#定义class专属常量（限制作用域）" class="headerlink" title="定义class专属常量（限制作用域）"></a>定义class专属常量（限制作用域）</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns;  <span class="comment">//声名式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NUmTurns = <span class="number">5</span>;   <span class="comment">//定义式</span></span><br></pre></td></tr></table></figure>
<p>（ps：只要不取NumTurns的地址，则无需提供定义式，即声名时便赋予初值）<br><strong>另一种方式：使用枚举类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认识 enum hack：<br>1，更像#define：不能取enum和#define的地址，避免非必要的内存分配<br>2，模板元变成的基础技术</p>
<h4 id="define的问题：宏表达式"><a href="#define的问题：宏表达式" class="headerlink" title="define的问题：宏表达式"></a>define的问题：宏表达式</h4><p>宏表达式的样子像函数，但是由于会被替换成实际代码，行为和函数也不同，容易造成错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用a和b中的较大者为参数来调用f()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p><strong>使用inline替换：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Type T&gt;      <span class="comment">//不清楚a和b的类型</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWIthMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有了const、enum、inline，降低了对预处理器（尤其是#define）的需求，但是#include仍然是必须的，#ifdef/#ifndef也用于控制编译<br><strong>请记住：</strong></p>
<ul>
<li>对于常量，最好以const对象或者enum替换#define</li>
<li>对于形似函数的宏，最好用inline函数替换#define</li>
</ul>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款03：尽可能使用const</title>
    <url>/2020/06/Effective-C++/Effective-CPP-03/</url>
    <content><![CDATA[<h3 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h3><p>1，告诉编译器和其他程序员某值应该保持不变<br>2，会获得编译器的帮助提示</p>
<h3 id="const的语法：常量声名"><a href="#const的语法：常量声名" class="headerlink" title="const的语法：常量声名"></a>const的语法：常量声名</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>1，如果const出现在*****的左边，表示被指物是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;   <span class="comment">//不可以修改*p，可以修改p</span></span><br></pre></td></tr></table></figure>
<p>2，如果const出现在*****的右边，表示指针自身是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;   <span class="comment">//可以修改*p，不可以修改p</span></span><br></pre></td></tr></table></figure>
<p>3，如果const出现在*****两边，表示被指物和指针都是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;   <span class="comment">//不可以修改*p，不可以修改p</span></span><br></pre></td></tr></table></figure>
<h3 id="const的语法：函数声名"><a href="#const的语法：函数声名" class="headerlink" title="const的语法：函数声名"></a>const的语法：函数声名</h3><p>在一个函数声名式中，const可以和函数返回值，参数，函数自身（成员函数）发生关系</p>
<h4 id="作用于参数"><a href="#作用于参数" class="headerlink" title="作用于参数"></a>作用于参数</h4><p>1，const参数类似于local const对象，参数不可修改<br>2，除非需要改动参数，否则应该声名为const</p>
<h4 id="作用于返回值"><a href="#作用于返回值" class="headerlink" title="作用于返回值"></a>作用于返回值</h4><p>预防“没有意义的赋值操作”，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">(a * b) = c;    <span class="comment">//在a * b的结果上调用operator=</span></span><br></pre></td></tr></table></figure>
<h4 id="作用于成员函数（const成员函数）"><a href="#作用于成员函数（const成员函数）" class="headerlink" title="作用于成员函数（const成员函数）"></a>作用于成员函数（const成员函数）</h4><p>目的是确认改成员函数可作用于const对象身上</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】37 - 解数独</title>
    <url>/2020/07/LeetCode/%E3%80%90LeetCode%E3%80%9137%20-%20%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p><strong>回溯法</strong>：从左到右，从上到下，遇到空格依次填入数字1-9，然后判断是否合法。如果该位置的数字合法，则继续向前试探；如果数字不合法，则回溯到上一步，填入下一个数字。如果该格子填入了数字1-9都不合法，那么就要继续回溯，以此类推。当所有的格子都被填完了，且合法，那么数独就解出来了。</p>
<h3 id="判断数字是否合法"><a href="#判断数字是否合法" class="headerlink" title="判断数字是否合法"></a>判断数字是否合法</h3><p>要想使得该空格上的数字合法，要满足下面三个要求（假设board[row][col] = num）:<br>1，第row行无数字num<br>2，第col列无数字num<br>3，该空格所属九宫格也没有数字num</p>
<h3 id="遍历该空格所处九宫格"><a href="#遍历该空格所处九宫格" class="headerlink" title="遍历该空格所处九宫格"></a>遍历该空格所处九宫格</h3><p>1，首先我们要找到该九宫格的左上角位置，从它开始遍历。即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">board[<span class="number">3</span> * (row / <span class="number">3</span>)][<span class="number">3</span> * (col / <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>然后依次从左上角格子开始，依次（从左到右，从上到下）遍历九宫格内的九个格子，这里需要巧妙使用除法（/）和取模（%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i从0-8</span></span><br><span class="line">board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        dfs(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有格子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//是否已经有数字</span></span><br><span class="line">                <span class="keyword">if</span>(board[row][col] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//尝试填入数字1-9</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> num = <span class="string">'1'</span>; num &lt;= <span class="string">'9'</span>; num++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//数字合法，向下试探</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isValid</span>(board, row, col, num))&#123;</span><br><span class="line">                        board[row][col] = num;</span><br><span class="line">                        <span class="comment">//向下试探</span></span><br><span class="line">                        <span class="keyword">if</span>(dfs(board))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//回溯</span></span><br><span class="line">                        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//数字1-9都不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/LeetCode/%E3%80%90LeetCode%E3%80%9137%20-%20%E8%A7%A3%E6%95%B0%E7%8B%AC-1.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯法  数独</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiny-Renderer-01  Bresenham画线算法</title>
    <url>/2020/06/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/Tiny-Renderer-01/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1，屏幕上的图像本质上是一个个不同颜色的小点<br>2，模型是由大量的三角形网格（mesh）组成的<br>3，这里我们先开始最基本的画线算法</p>
<h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><p>想要在两点之间画一条线段，本质上就是在这两点之间寻找一系列最接近这条直线的像素点来模拟这条直线。根据Bresenham画线算法，利用直线的参数方程，我们可以写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_1</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">float</span> t = <span class="number">0</span>; t &lt; <span class="number">1</span>; t += <span class="number">0.001</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = x0 + (x1 - x0) * t;</span><br><span class="line">		<span class="keyword">int</span> y = y0 + (y1 - y0) * t;</span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中（x0，y0）和（x1，y1）分别是起终点的坐标，image是绘制的目标图片，Color表示这条线段上的点的颜色<br><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/1-1.png" alt="line_1()画出的线段"></p>
<h2 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h2><p>line_1函数首先是低效的，但其实它最大的问题在于<strong>间隔常数</strong>的选择，上述代码中我选择了0.001作为步长，画出来的线段像素点很密集，但是如果我将常数选择为0.01甚至是0.1，那么将会画出下面这样的线段：<br><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/1-2.png" alt="line_1()画出的像我头发一样稀疏的线段"></p>
<p>1，当间隔常数选择过大时，画出来的线段过于稀疏。<br>2，当间隔常数选择过小时，画出来的线段虽然很密集，但是会出现很多点重合在一起的情况，这样大大降低了画线的效率<br>可以这样认为，间隔常数代表了每次前进的步长，其实就是控制了两点之间线段上<strong>像素点的个数</strong>，我们可以这样改写代码（仍然存在问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_2</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">		<span class="comment">//这里需注意不能除以int类型的</span></span><br><span class="line">		<span class="keyword">float</span> t = (x - x0) / (<span class="keyword">float</span>)(x1 - x0);</span><br><span class="line">		<span class="keyword">int</span> y = y0 * (<span class="number">1.0</span> - t) + y1 * (<span class="keyword">double</span>)t;</span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：需要将x1-x0的结果转换成浮点数类型，不然会在接下来的除法中损失精度）<br>用上面的画线算法来试着画三条线段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">line_2(<span class="number">20</span>, <span class="number">13</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="built_in">image</span>, Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"><span class="comment">//下面两条线段方向相反，颜色一白一红</span></span><br><span class="line">line_2(<span class="number">13</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">40</span>, <span class="built_in">image</span>, Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">line_2(<span class="number">80</span>, <span class="number">40</span>, <span class="number">13</span>, <span class="number">20</span>, <span class="built_in">image</span>, Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/1-3.png" alt="line_2()画的三条线段"><br>1，平缓的白色线段表现良好，像素点密集；陡峭的红色线段表现一般，像素点较为稀疏。<br>2，这里我们画了三条线，但是只出现了两条线。<br>仔细分析一下：</p>
<blockquote>
<p>   我们先画了从（13, 20）到（80, 40）的白色线段；然后紧接着画了从（80, 40）到（13, 20）的红色线段。按照我们设想的来说，应该是后画的红色会覆盖掉先画的白色线&gt; 段。但是程序没有按照我们预期的执行，红色线段没有出现，也就是没有绘制。这也就是意味着，line_2函数是否执行跟线段的方向有关。line_2函数不满足<strong>对称性</strong>。</p>
</blockquote>
<h2 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h2><p>现在我们需要解决版本二中画线函数的问题：</p>
<blockquote>
<p>  （1）当线段陡峭的时候（斜率大于1），画出来的线段像素点比较稀疏<br>  （2）若x0 &lt; x1，则无法画线（for循环的初始条件）</p>
</blockquote>
<p>我们的方法是：</p>
<blockquote>
<p>  （1）当线段陡峭时，交换x轴和y轴，用<strong>跨度较大的维度前进</strong>，画出较多的像素点<br>  （2）判断x0和x1的大小关系，保证<strong>从左向右</strong>画线</p>
</blockquote>
<p>修正的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_3</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//是否陡峭</span></span><br><span class="line">	<span class="comment">//如果陡峭的话,则交换x轴和y轴，用跨度大的轴前进</span></span><br><span class="line">	<span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, y0);</span><br><span class="line">		<span class="built_in">std</span>::swap(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证从左向右画线</span></span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, x1);</span><br><span class="line">		<span class="built_in">std</span>::swap(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x0; x &lt;= x1; x++) &#123;</span><br><span class="line">		<span class="keyword">float</span> t = (x - x0) / (<span class="keyword">float</span>)(x1 - x0);</span><br><span class="line">		<span class="keyword">int</span> y = y0 * (<span class="number">1.0</span> - t) + y1 * (<span class="keyword">double</span>)t;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			<span class="comment">//前面因为陡峭交换了坐标轴，这里需要交换回来</span></span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/1-4.png" alt="line_3()画的三条线段"></p>
<h2 id="版本三的优化"><a href="#版本三的优化" class="headerlink" title="版本三的优化"></a>版本三的优化</h2><p>1，line_3函数已经是个正确的函数了，它可以在直线陡峭，反向的时候判断修正，画出正确的线段。<br>2，但是为了保证渲染器的高效，我们要尽可能地优化画线函数地效率<br>分析一下存在的效率问题：</p>
<blockquote>
<p>   1，被除数x1-x0是常数，可以拿到循环外部<br>   2，算法中存在除法和乘法这样低效的运算</p>
</blockquote>
<p>我们可以参考中点画线算法的思想，来修正像素的落点，代码修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_4</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果陡峭的话,则交换x轴和y轴，用跨度大的轴前进</span></span><br><span class="line">	<span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, y0);</span><br><span class="line">		<span class="built_in">std</span>::swap(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证从左向右画线</span></span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, x1);</span><br><span class="line">		<span class="built_in">std</span>::swap(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//直线斜率的绝对值</span></span><br><span class="line">	<span class="keyword">float</span> k = <span class="built_in">std</span>::<span class="built_in">abs</span>((y1 - y0) / <span class="keyword">float</span>(x1 - x0));</span><br><span class="line">	<span class="keyword">float</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x0, y = y0; x &lt;= x1; ++x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//修正下一个像素的落点</span></span><br><span class="line">		error += k;</span><br><span class="line">		<span class="keyword">if</span> (error &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">			y += (y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">			error -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1，这里的k值是斜线的斜率<br>2，误差变量error当前的点（x，y）距离最佳直线（下一次最佳落点）的距离，每当error大于0.5时，说明下次的落点将偏离最佳落点，需要修正落点，保证每次的error的绝对值都在0.5以内。<br>3，关于修正的方向：因为我们保证了画线的方向始终是从左到右，因此在判断直线方向的时候（斜率正负），我们只需要起终点的y值大小即可。</p>
<h2 id="进一步的优化"><a href="#进一步的优化" class="headerlink" title="进一步的优化"></a>进一步的优化</h2><p>我们优化了算法中的除法和乘法，将它们修正成了简单的加法。现在我们要将目光放在算法中的浮点数上。仔细观察出现浮点数地方：</p>
<blockquote>
<p>   1，计算斜率的绝对值（k）和误差变量error<br>   2，error和0.5的比较</p>
</blockquote>
<p>1，首先我们可以从(error &gt; 0.5)这个浮点数比较来入手，保证比较的两边都是整数，最简单的方法就是不等号两边同时诚意2，即 ：error * 2 &gt; 1<br>2，接下来我们考虑有关k（斜率的绝对值）的运算，我们可以将被除数dx移到等式右边，即 ：error * （x1 - x0） += （y1 - y0）<br>3，将1，2两步综合起来，新的误差变量为原来的 2 * (x1 - x0)倍，代码修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_5</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果陡峭的话,则交换x轴和y轴，用跨度大的轴前进</span></span><br><span class="line">	<span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, y0);</span><br><span class="line">		<span class="built_in">std</span>::swap(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证从左向右画线</span></span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, x1);</span><br><span class="line">		<span class="built_in">std</span>::swap(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dx = x1 - x0;</span><br><span class="line">	<span class="keyword">int</span> dy = y1 - y0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">abs</span>(dy) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x0, y = y0; x &lt;= x1; ++x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//修正下一个像素的落点</span></span><br><span class="line">		error += k;</span><br><span class="line">		<span class="keyword">if</span> (error &gt; dx) &#123;</span><br><span class="line">			y += (y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">			error -= <span class="number">2</span> * dx;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于局部变量"><a href="#关于局部变量" class="headerlink" title="关于局部变量"></a>关于局部变量</h2><p>我们注意到，在循环内有一些判断和局部变量，比如是否陡峭（steep）和(y1 &gt; y0 ? 1 : -1)。我们可以将他们放到循环之外进行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_6</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果陡峭的话,则交换x轴和y轴，用跨度大的轴前进</span></span><br><span class="line">	<span class="keyword">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(x0 - x1) &lt; <span class="built_in">std</span>::<span class="built_in">abs</span>(y0 - y1)) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, y0);</span><br><span class="line">		<span class="built_in">std</span>::swap(x1, y1);</span><br><span class="line">		steep = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证从左向右画线</span></span><br><span class="line">	<span class="keyword">if</span> (x0 &gt; x1) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x0, x1);</span><br><span class="line">		<span class="built_in">std</span>::swap(y0, y1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dx = (x1 - x0);</span><br><span class="line">	<span class="keyword">int</span> dy = (y1 - y0);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">abs</span>(dy) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> y_dir = y1 &gt; y0 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (steep) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = x0, y = y0; x &lt;= x1; ++x) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(y, x, color);</span><br><span class="line">			error += k;</span><br><span class="line">			<span class="keyword">if</span> (error &gt; dx) &#123;</span><br><span class="line">				y += y_dir;</span><br><span class="line">				error - <span class="number">2</span> * dx;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = x0, y = y0; x &lt;= x1; ++x) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">			error += k;</span><br><span class="line">			<span class="keyword">if</span> (error &gt; dx) &#123;</span><br><span class="line">				y += y_dir;</span><br><span class="line">				error -= <span class="number">2</span> * dx;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是现在的编译器已经相当智能了，应该会自动进行优化吧（猜测）。</p>
<h2 id="线框渲染"><a href="#线框渲染" class="headerlink" title="线框渲染"></a>线框渲染</h2><p>有了最基础的画线算法，我们就可以根据模型文件（.obj）中的信息来绘制模型的线框模型。<br>1，首先需要读取obj文件，提取顶点和面信息<br>2，根据顶点和面信息来绘制图片<br>（有关obj文件的读取与解析，这里先挖个坑）</p>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/1-5.png" alt="线框渲染"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>Bresenham</tag>
        <tag>画线算法</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Tiny-Renderer-02  三角形光栅化+消隐</title>
    <url>/2020/07/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/Tiny-Renderer-02/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇的末尾，我们依靠Bresenham画线算法和从.obj文件中读取出来的vertex和face信息来绘制了线框模型。我们知道模型在渲染的时候，多边形会被解算成三角形，而这一次我们的任务就是绘制并填充三角形。</p>
<h2 id="传统方法：扫描线填充算法"><a href="#传统方法：扫描线填充算法" class="headerlink" title="传统方法：扫描线填充算法"></a>传统方法：扫描线填充算法</h2><h3 id="绘制线框三角形"><a href="#绘制线框三角形" class="headerlink" title="绘制线框三角形"></a>绘制线框三角形</h3><p>首先我们来绘制一个三角形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制三角形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">line</span>(t0, t1, <span class="built_in">image</span>, color);</span><br><span class="line">	<span class="built_in">line</span>(t1, t2, <span class="built_in">image</span>, color);</span><br><span class="line">	<span class="built_in">line</span>(t2, t0, <span class="built_in">image</span>, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">PNGImage <span class="title">image</span><span class="params">(<span class="number">200</span>,<span class="number">200</span>,RGBCOLOR)</span></span>;</span><br><span class="line"></span><br><span class="line">	Vec2i t0[<span class="number">3</span>] = &#123; Vec2i(<span class="number">10</span>, <span class="number">70</span>),   Vec2i(<span class="number">50</span>, <span class="number">160</span>),  Vec2i(<span class="number">70</span>, <span class="number">80</span>) &#125;;</span><br><span class="line">	Vec2i t1[<span class="number">3</span>] = &#123; Vec2i(<span class="number">180</span>, <span class="number">50</span>),  Vec2i(<span class="number">150</span>, <span class="number">1</span>),   Vec2i(<span class="number">70</span>, <span class="number">180</span>) &#125;;</span><br><span class="line">	Vec2i t2[<span class="number">3</span>] = &#123; Vec2i(<span class="number">180</span>, <span class="number">150</span>), Vec2i(<span class="number">120</span>, <span class="number">160</span>), Vec2i(<span class="number">130</span>, <span class="number">180</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	triangle(t0[<span class="number">0</span>], t0[<span class="number">1</span>], t0[<span class="number">2</span>], <span class="built_in">image</span>, red);</span><br><span class="line">	triangle(t1[<span class="number">0</span>], t1[<span class="number">1</span>], t1[<span class="number">2</span>], <span class="built_in">image</span>, white);</span><br><span class="line">	triangle(t2[<span class="number">0</span>], t2[<span class="number">1</span>], t2[<span class="number">2</span>], <span class="built_in">image</span>, green);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">image</span>.save(<span class="string">"image/2-1.png"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-1.png" alt="线框三角形"><br>1，这里我将画线函数的输入改成了自定义的二维向量，减少函数原型的长度<br>2，绘制线框三角形，即三个顶点两两连接画线即可</p>
<h3 id="扫描线填充算法"><a href="#扫描线填充算法" class="headerlink" title="扫描线填充算法"></a>扫描线填充算法</h3><p>一个好的填充算法应该具备以下特点：</p>
<blockquote>
<p>简单，快速，高效<br>具有对称性：即绘制三角形的结果和输入顶点的顺序无关<br>如果两个三角形共边，则三角形之间需要无缝贴合</p>
</blockquote>
<p>传统的扫描线填充算法：</p>
<blockquote>
<p>将三角形的顶点顺序按y排序<br>将三角形分成上下两部分<br>分别对上下两部分进行填充</p>
</blockquote>
<h3 id="顶点排序"><a href="#顶点排序" class="headerlink" title="顶点排序"></a>顶点排序</h3><p>将三角形的三个顶点t0,t1,t2按照y坐标大小升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将t0，t1，t2按y大小升序排序</span></span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t1.y) <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t2.y) <span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">	<span class="keyword">if</span> (t1.y &gt; t2.y) <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">line</span>(t0, t1, <span class="built_in">image</span>, green);</span><br><span class="line">	<span class="built_in">line</span>(t1, t2, <span class="built_in">image</span>, green);</span><br><span class="line">	<span class="built_in">line</span>(t2, t0, <span class="built_in">image</span>, red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-2.png" alt=""><br>1，红色边界是完整的边界，绿色边界则包含两部分，我们需要将绿色边界分成上下两部分分别进行填充。<br>2，可以这样来看，过绿色边界上的顶点作一条水平线，分成上下两部分分别进行填充</p>
<h3 id="绘制边界点"><a href="#绘制边界点" class="headerlink" title="绘制边界点"></a>绘制边界点</h3><p>根据绿色边界上的转折点（排序之后的t1），将三角形分成上下两部分，分别绘制出边界点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制边界点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//顶点升序排序t0,t1,t2</span></span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t1.y) <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t2.y) <span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">	<span class="keyword">if</span> (t1.y &gt; t2.y) <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//总高度</span></span><br><span class="line">	<span class="keyword">int</span> total_height = t2.y - t0.y;</span><br><span class="line">	<span class="comment">//绘制下半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = t0.y; y &lt;= t1.y; y++) &#123;</span><br><span class="line">		<span class="keyword">int</span> segment_height = t1.y - t0.y + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//直线的参数方程</span></span><br><span class="line">		<span class="keyword">float</span> tA = (<span class="keyword">float</span>)(y - t0.y) / total_height;</span><br><span class="line">		<span class="keyword">float</span> tB = (<span class="keyword">float</span>)(y - t0.y) / segment_height;</span><br><span class="line">		<span class="comment">//左右两部分的点</span></span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * tA;</span><br><span class="line">		Vec2i B = t0 + (t1 - t0) * tB;</span><br><span class="line">		<span class="comment">//画点</span></span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(A.x, y, red);</span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(B.x, y, green);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制上半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = t1.y; y &lt;= t2.y; y++) &#123;</span><br><span class="line">		<span class="keyword">int</span> segment_height = t2.y - t1.y + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//直线的参数方程</span></span><br><span class="line">		<span class="keyword">float</span> tA = (<span class="keyword">float</span>)(y - t0.y) / total_height;</span><br><span class="line">		<span class="keyword">float</span> tB = (<span class="keyword">float</span>)(y - t1.y) / segment_height;</span><br><span class="line">		<span class="comment">//左右两部分的点</span></span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * tA;</span><br><span class="line">		Vec2i B = t1 + (t2 - t1) * tB;</span><br><span class="line">		<span class="comment">//画点</span></span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(A.x, y, red);</span><br><span class="line">		<span class="built_in">image</span>.<span class="built_in">set</span>(B.x, y, green);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-3.png" alt="三角形的边界点"></p>
<h3 id="填充三角形"><a href="#填充三角形" class="headerlink" title="填充三角形"></a>填充三角形</h3><p>1，仔细观察绘制出的边界点和最开始绘制出的线框三角形，可以发现在直线斜率绝对值（|k|）较小的时候，会出现直线不连续，点迹稀疏的现象。<br>2，这里的相邻稀疏点迹y值差1，这时候只需要将左右两个边界的点连接（扫描线填充）起来就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//填充三角形</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//顶点升序排序t0,t1,t2</span></span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t1.y) <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t2.y) <span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">	<span class="keyword">if</span> (t1.y &gt; t2.y) <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//总高度</span></span><br><span class="line">	<span class="keyword">int</span> total_height = t2.y - t0.y;</span><br><span class="line">	<span class="comment">//绘制下半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = t0.y; y &lt;= t1.y; y++) &#123;</span><br><span class="line">		<span class="keyword">int</span> segment_height = t1.y - t0.y + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//直线的参数方程</span></span><br><span class="line">		<span class="keyword">float</span> tA = (<span class="keyword">float</span>)(y - t0.y) / total_height;</span><br><span class="line">		<span class="keyword">float</span> tB = (<span class="keyword">float</span>)(y - t0.y) / segment_height;</span><br><span class="line">		<span class="comment">//左右两部分的点</span></span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * tA;</span><br><span class="line">		Vec2i B = t0 + (t1 - t0) * tB;</span><br><span class="line">		<span class="comment">//填充AB之间的点，保证从左到右填充</span></span><br><span class="line">		<span class="keyword">if</span> (A.x &gt; B.x) <span class="built_in">std</span>::swap(A, B);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = A.x; x &lt;= B.x; x++) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绘制上半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = t1.y; y &lt;= t2.y; y++) &#123;</span><br><span class="line">		<span class="keyword">int</span> segment_height = t2.y - t1.y + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//直线的参数方程</span></span><br><span class="line">		<span class="keyword">float</span> tA = (<span class="keyword">float</span>)(y - t0.y) / total_height;</span><br><span class="line">		<span class="keyword">float</span> tB = (<span class="keyword">float</span>)(y - t1.y) / segment_height;</span><br><span class="line">		<span class="comment">//左右两部分的点</span></span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * tA;</span><br><span class="line">		Vec2i B = t1 + (t2 - t1) * tB;</span><br><span class="line">		<span class="comment">//填充AB之间的点，保证从左到右填充</span></span><br><span class="line">		<span class="keyword">if</span> (A.x &gt; B.x) <span class="built_in">std</span>::swap(A, B);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = A.x; x &lt;= B.x; x++) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, y, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-4.png" alt="三角形填充"></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>1，在函数的一开始，需要对传入的点参数进行判断<br>2，绘制上下两部分的循环思路类似，可以合并在一起</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//参数判断：传入的三个点共线，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (t0.y == t1.y &amp;&amp; t0.y == t2.y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//顶点升序排序t0,t1,t2</span></span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t1.y) <span class="built_in">std</span>::swap(t0, t1);</span><br><span class="line">	<span class="keyword">if</span> (t0.y &gt; t2.y) <span class="built_in">std</span>::swap(t0, t2);</span><br><span class="line">	<span class="keyword">if</span> (t1.y &gt; t2.y) <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//总高度</span></span><br><span class="line">	<span class="keyword">int</span> total_height = t2.y - t0.y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total_height; i++) &#123;</span><br><span class="line">		<span class="comment">//是否是上半部分</span></span><br><span class="line">		<span class="keyword">bool</span> second_half = i &gt; (t1.y - t0.y) || (t1.y == t0.y);</span><br><span class="line">		<span class="keyword">int</span> segment_height = second_half ? (t2.y - t1.y) : (t1.y - t0.y);</span><br><span class="line">		<span class="comment">//参数方程</span></span><br><span class="line">		<span class="keyword">float</span> tA = (<span class="keyword">float</span>)i / total_height;</span><br><span class="line">		<span class="keyword">float</span> tB = (<span class="keyword">float</span>)(i - (second_half ? (t1.y - t0.y) : <span class="number">0</span>)) / segment_height;</span><br><span class="line">		<span class="comment">//边界点</span></span><br><span class="line">		Vec2i A = t0 + (t2 - t0) * tA;</span><br><span class="line">		Vec2i B = second_half ? (t1 + (t2 - t1) * tB) : (t0 + (t1 - t0) * tB);</span><br><span class="line">		<span class="comment">//填充</span></span><br><span class="line">		<span class="keyword">if</span> (A.x &gt; B.x) <span class="built_in">std</span>::swap(A, B);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = A.x; x &lt;= B.x; x++) &#123;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(x, t0.y + i, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="新的方法：边界框-判断点是否在三角形内部"><a href="#新的方法：边界框-判断点是否在三角形内部" class="headerlink" title="新的方法：边界框+判断点是否在三角形内部"></a>新的方法：边界框+判断点是否在三角形内部</h2><p>1，扫描线填充算法思路比较简单，但是实现起来代码稍显庞杂，而且适合于单线程的CPU<br>2，这里有一种更简单的方法，使用判断点是否在三角形内+边界框：遍历边界框内的所有点，若该点在三角形内，则画点；否则就跳过。</p>
<h3 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h3><p>给定三角形ABC和一点P，判断点P是否在三角形ABC内部，有很多方法：</p>
<blockquote>
<p>内角和法<br>射线法检验交点数<br>同向法<br>重心法</p>
</blockquote>
<p>其中重心法使用了一些数学方法，速度很快，这里我们选择使用重心法。<br>1，对于平面内任意一点，都可以由如下方程来表示：</p>
<center>P = A  + u * (C – A) + v * (B - A)</center>
<center>  = (1 - u - v) * A + u * B+ v * C</center>
则点P在三角形内部的条件是：
<center>u >= 0</center>
<center>v >= 0</center>
<center>u + v <= 1</center>
2，将改方程简单变形求解出u，v即可
下面是实现代码：

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向量的叉乘</span></span><br><span class="line"><span class="keyword">inline</span> Vec3&lt;t&gt; <span class="keyword">operator</span> ^(<span class="keyword">const</span> Vec3&lt;t&gt; &amp;v) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Vec3&lt;t&gt;(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Vec3f barycentric(Vec2i* pts, Vec2i P) &#123;</span><br><span class="line">	</span><br><span class="line">	Vec3f v1 = &#123; (<span class="keyword">float</span>)(pts[<span class="number">2</span>].x - pts[<span class="number">0</span>].x), (<span class="keyword">float</span>)(pts[<span class="number">1</span>].x - pts[<span class="number">0</span>].x), (<span class="keyword">float</span>)(pts[<span class="number">0</span>].x - P.x) &#125;;</span><br><span class="line">	Vec3f v2 = &#123; (<span class="keyword">float</span>)(pts[<span class="number">2</span>].y - pts[<span class="number">0</span>].y), (<span class="keyword">float</span>)(pts[<span class="number">1</span>].y - pts[<span class="number">0</span>].y), (<span class="keyword">float</span>)(pts[<span class="number">0</span>].y - P.y) &#125;;</span><br><span class="line"></span><br><span class="line">	Vec3f u = v1 ^ v2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(u.y &lt; <span class="number">1</span>)) <span class="keyword">return</span> Vec3f(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> Vec3f(<span class="number">1.0f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角形填充算法"><a href="#三角形填充算法" class="headerlink" title="三角形填充算法"></a>三角形填充算法</h3><p>1，上面实现了判断一个点是否在三角形内部，下面加上对三角形边界框的限制即可，这里使用左下和右上两个点来记录矩形边界框<br>2，在进行填充的时候，遍历边界框内的所有像素点，判断是否在三角形内部即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangle</span><span class="params">(Vec2i* pts, PNGImage&amp; <span class="built_in">image</span>, Color color)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//边界框，左下，右上</span></span><br><span class="line">	Vec2i bboxmax = &#123; <span class="built_in">image</span>.get_width() - <span class="number">1</span>,<span class="built_in">image</span>.get_height()<span class="number">-1</span> &#125;;</span><br><span class="line">	Vec2i bboxmin = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 图像大小的限制</span></span><br><span class="line">	Vec2i clamp = &#123; <span class="built_in">image</span>.get_width() - <span class="number">1</span>,<span class="built_in">image</span>.get_height() - <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		bboxmin.x = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(bboxmin.x, pts[i].x));</span><br><span class="line">		bboxmax.x = <span class="built_in">std</span>::<span class="built_in">min</span>(clamp.x, <span class="built_in">std</span>::<span class="built_in">max</span>(bboxmax.x, pts[i].x));</span><br><span class="line">		</span><br><span class="line">		bboxmin.y = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(bboxmin.y, pts[i].y));</span><br><span class="line">		bboxmax.y = <span class="built_in">std</span>::<span class="built_in">min</span>(clamp.y, <span class="built_in">std</span>::<span class="built_in">max</span>(bboxmax.y, pts[i].y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当前点</span></span><br><span class="line">	Vec2i cur;</span><br><span class="line">	<span class="keyword">for</span> (cur.x = bboxmin.x; cur.x &lt;= bboxmax.x; cur.x++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (cur.y = bboxmin.y; cur.y &lt;= bboxmax.y; cur.y++) &#123;</span><br><span class="line">			Vec3f u = barycentric(pts, cur);</span><br><span class="line">			<span class="keyword">if</span> (u.x &lt; <span class="number">0</span> || u.y &lt; <span class="number">0</span> || u.z &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">image</span>.<span class="built_in">set</span>(cur.x, cur.y, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-5.png" alt="边界框+三角形内部法"></p>
<h2 id="平面阴影渲染"><a href="#平面阴影渲染" class="headerlink" title="平面阴影渲染"></a>平面阴影渲染</h2><h3 id="渲染测试"><a href="#渲染测试" class="headerlink" title="渲染测试"></a>渲染测试</h3><p>在上一篇中，我们渲染了线框模型。上面我们完成了三角形的填充算法，可以尝试渲染面填充的模型，这里我们对三角面随机填充颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机填充颜色</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">PNGImage <span class="title">image</span><span class="params">(<span class="built_in">width</span>, <span class="built_in">height</span>,RGBCOLOR)</span></span>;</span><br><span class="line"></span><br><span class="line">	Model* model = <span class="keyword">new</span> Model(<span class="string">"obj/african_head.obj"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; model-&gt;nfaces(); i++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; face = model-&gt;face(i);</span><br><span class="line">		Vec2i screen_coords[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			Vec3f world_coords = model-&gt;vert(face[j]);</span><br><span class="line">			screen_coords[j] = Vec2i((world_coords.x + <span class="number">1.</span>) * <span class="built_in">width</span> / <span class="number">2.</span>, (world_coords.y + <span class="number">1.</span>) * <span class="built_in">height</span> / <span class="number">2.</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		triangle(screen_coords[<span class="number">0</span>], screen_coords[<span class="number">1</span>], screen_coords[<span class="number">2</span>], <span class="built_in">image</span>, Color(rand() % <span class="number">255</span>, rand() % <span class="number">255</span>, rand() % <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">image</span>.save(<span class="string">"image/2-7.png"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-6.png" alt="随机填充颜色"></p>
<h3 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h3><p>接下来我们给模型添加一些简单的光影信息，首先需要明确的是：<br>1，在同样的光线强度下，当多边形与光线方向正交时，它被照亮得最明亮。<br>2，如果多边形平行于光矢量，我们得到零光照。<br>把这两句常识转换成数学上的专业术语便是：</p>
<center>光照强度等于光的方向向量和给定三角形法线法向的标量积。</center>
我们又知道三角形的发现方向可以通过计算两条边的叉乘获得。
我们可以按照下面的方式进行渲染：

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//光影</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">PNGImage <span class="title">image</span><span class="params">(<span class="built_in">width</span>, <span class="built_in">height</span>,RGBCOLOR)</span></span>;</span><br><span class="line"></span><br><span class="line">	Model* model = <span class="keyword">new</span> Model(<span class="string">"obj/african_head.obj"</span>);</span><br><span class="line">    <span class="comment">//光线方向</span></span><br><span class="line">	<span class="function">Vec3f <span class="title">light_dir</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; model-&gt;nfaces(); i++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;face = model-&gt;face(i);</span><br><span class="line">		<span class="comment">//屏幕坐标</span></span><br><span class="line">		Vec2i screen_coords[<span class="number">3</span>];</span><br><span class="line">		<span class="comment">//世界坐标</span></span><br><span class="line">		Vec3f world_coords[<span class="number">3</span>];</span><br><span class="line">		<span class="comment">//世界坐标到屏幕坐标的转换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			Vec3f v = model-&gt;vert(face[j]);</span><br><span class="line">			screen_coords[j] = Vec2i((v.x + <span class="number">1.0f</span>) * <span class="built_in">width</span> / <span class="number">2.0f</span>, (v.y + <span class="number">1.0f</span>) * <span class="built_in">height</span> / <span class="number">2.0f</span>);</span><br><span class="line">			world_coords[j] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//法线</span></span><br><span class="line">		Vec3f n = (world_coords[<span class="number">2</span>] - world_coords[<span class="number">0</span>]) ^ (world_coords[<span class="number">1</span>] - world_coords[<span class="number">0</span>]);</span><br><span class="line">		n.normalize();</span><br><span class="line">		<span class="keyword">float</span> intensity = n * light_dir;</span><br><span class="line">		<span class="keyword">if</span> (intensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			triangle(screen_coords[<span class="number">0</span>], screen_coords[<span class="number">1</span>], screen_coords[<span class="number">2</span>], <span class="built_in">image</span>, Color(intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, intensity * <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">image</span>.save(<span class="string">"image/2-8.png"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/Tiny-Renderer/2-8.png" alt=""><br>1，这里的光是从正面照射向图片的。<br>2，模型背部的三角面片的法线方向和光的方向是相同的，接收不到光照，计算出来的intensity大于0，这部分的就根据光照被剔除了。这种方法叫做背面剔除（Back-face culling）<br>3，我们可以看到，嘴巴里面的口腔是暴露在外面的（正常的渲染应该被剔除），这里的原因是我们使用的背面剔除方法只适合于凸多边形，不适合凹多边形。我们会在以后完善它（使用Z-buffer）。</p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>消隐</tag>
        <tag>三角形</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客实用技巧</title>
    <url>/2020/05/%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="Hexo免密部署到Github"><a href="#Hexo免密部署到Github" class="headerlink" title="Hexo免密部署到Github"></a>Hexo免密部署到Github</h3><p>1，新建系统环境变量</p>
<pre><code>Home
%USERPROFILE%</code></pre><p>2，在用户目录(C:\Users\username)下新建_netrc.txt文件，在文件中输入：</p>
<pre><code>machine github.com
login username
password password</code></pre><h3 id="添加分类功能"><a href="#添加分类功能" class="headerlink" title="添加分类功能"></a>添加分类功能</h3><p>1，在博客的根目录下执行以下命令</p>
<pre><code>hexo new page categories</code></pre><p>该命令会在source文件夹下生成一个categories文件夹，categories文件夹下会有index.md这个文件。<br>2，在index.md下添加type: categories，添加后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2019</span><span class="number">-04</span><span class="number">-24</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">30</span></span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这里的title是HTML页面的title，可修改成自己想要的<br>3，在编辑新的markdown文件时，需要给文章添加categories属性，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: <span class="number">2017</span><span class="number">-05</span><span class="number">-26</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">57</span></span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>（ps：一篇文章只会有一个分类，默认是第一个）</p>
<h3 id="添加标签功能"><a href="#添加标签功能" class="headerlink" title="添加标签功能"></a>添加标签功能</h3><p>1，在博客的根目录下执行以下命令</p>
<pre><code>hexo new page tags</code></pre><p>该命令会在source文件夹下生成一个tags文件夹，tags文件夹下会有index.md这个文件。<br>2，在index.md下添加type: tags，添加后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2019</span><span class="number">-04</span><span class="number">-24</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">30</span></span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>3，在编辑新的markdown文件时，需要给文章添加tags属性，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: <span class="number">2017</span><span class="number">-05</span><span class="number">-26</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">57</span></span><br><span class="line">categories: </span><br><span class="line">        - Hexo</span><br><span class="line">tags：</span><br><span class="line">        - 博客技巧</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>（ps：一篇文章可以有多个标签）</p>
<h3 id="修改内容区域宽度"><a href="#修改内容区域宽度" class="headerlink" title="修改内容区域宽度"></a>修改内容区域宽度</h3><p>next主题默认的宽带有点窄，留白太多，文章宽度不够<br>打开/Hexo/themes/hexo-theme-next/source//css/_variables/custom.styl 添加两行代码即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$main-desktop = <span class="number">1200</span>px </span><br><span class="line">$content-desktop = <span class="number">900</span>px</span><br></pre></td></tr></table></figure>

<h3 id="使用GitHub作为博客图床"><a href="#使用GitHub作为博客图床" class="headerlink" title="使用GitHub作为博客图床"></a>使用GitHub作为博客图床</h3><p>1，新建一个仓库存放图片，为了便于分类和管理，可以放在不同分支下<br>2，将需要使用的图片上传到指定分支下<br>3，复制图片所在页面的URL<br>4，嵌入markdown，<strong>注意:</strong> 需要将链接中的blob修改成raw</p>
]]></content>
      <categories>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>常见10种排序算法</title>
    <url>/2020/06/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%8110%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="常见的排序算法可以分成两类"><a href="#常见的排序算法可以分成两类" class="headerlink" title="常见的排序算法可以分成两类"></a>常见的排序算法可以分成两类</h2><h3 id="非线性时间-比较类排序"><a href="#非线性时间-比较类排序" class="headerlink" title="非线性时间 比较类排序"></a>非线性时间 比较类排序</h3><p>1，通过<strong>比较</strong>来决定元素间的相对次序<br>2，其时间复杂度不能突破O(nlogn)</p>
<h3 id="线性时间-非比较类排序"><a href="#线性时间-非比较类排序" class="headerlink" title="线性时间 非比较类排序"></a>线性时间 非比较类排序</h3><p>1，不通过比较来决定元素间的相对次序<br>2，可以突破基于比较排序的时间下界，以线性时间运行<br><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="排序算法的分类"></p>
<h2 id="非线性时间比较类"><a href="#非线性时间比较类" class="headerlink" title="非线性时间比较类"></a>非线性时间比较类</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>思路：</strong><br>外层循环从1到n-1（一共n-1趟），内层循环从当前外层元素的下一个位置开始，依次和下一个元素比较，出现逆序就交换，把相邻元素的较小者交换到前面。看起来就像每趟最大的元素依次交换，移动到最后（冒泡）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//外层循环控制排序趟数，共n-1趟</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="comment">//内层循环控制每一趟排序次数</span></span><br><span class="line">		<span class="comment">//最末尾的i个已经被排好了,所以j的范围是0到size-1-i</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span> - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化：</strong><br>1，冒泡排序在数据元素<strong>基本有序</strong>的时候性能很好，只要在一次遍历过程中发现数组有序，就可以立即结束<br>2，加入<strong>swap标志</strong>，当前一轮没有进行交换的时候，说明数组已经有序，下一轮可以直接break。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外层循环控制排序趟数，共n-1趟</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> swap = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//内层循环控制每一趟排序次数</span></span><br><span class="line">		<span class="comment">//最末尾的i个已经被排好了,所以j的范围是0到size-1-i</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span> - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">				swap = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!swap) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序动态图"><br><strong>特点：</strong><br>1，冒泡排序是<strong>稳定</strong>的排序算法<br>2，思路和实现都很简单，适合小数组排序<br>3，算法复杂度较高，不适合数据规模较大时使用</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><strong>思路：</strong><br>在<strong>未排序序列种找到最小者</strong>，存放到排序序列的末尾位置，以此类推，直到所有的元素均排序完毕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="comment">//已排序序列0到i，未排序序列i到size-1</span></span><br><span class="line">		<span class="comment">//找到未排序序列的最小元素arr[min]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123;</span><br><span class="line">				<span class="built_in">min</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将找到的最小元素放到已排序序列的末尾</span></span><br><span class="line">		<span class="built_in">std</span>::swap(arr[<span class="built_in">min</span>], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序动态图"><br><strong>特点：</strong><br>1，数组实现的选择排序是<strong>不稳定</strong>的，链表实现的选择排序是稳定的<br>2，思路和实现比较简单<br>3，复杂度波动小，优于冒泡排序<br>4，复杂度较高，只适合小规模数组排序</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>思路：</strong><br>1，对于未排序序列中的一个元素，在已排序序列种从后向前扫描，找到相应的位置插入<br>2，类似于扑克牌摸牌，手牌都是已排序的，牌堆都是未排序的。摸一张牌，找到合适的位置插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//一开始的已排序序列0，未排序序列1到n-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="comment">//当前未排序序列的一个元素</span></span><br><span class="line">		<span class="keyword">int</span> key = arr[i];</span><br><span class="line">		<span class="comment">//已排序序列的末尾位置</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			--j;<span class="comment">//向前移动</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入到相应位置</span></span><br><span class="line">		arr[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序动态图"><br><strong>特点：</strong><br>1，插入排序是<strong>稳定</strong>的排序算法<br>2，复杂度较高，不适合大规模数组<br>3，一般作为<strong>快速排序的补充</strong>如：<br>STL中的sort和stdlib中的qsort算法，会将插入排序作为快速排序的补充<br>JDK 7中Arrays中的sort，会在数组长度小于47的时候，使用插入排序</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>思路：</strong><br>1，希尔排序是插入排序的一种高效实现，也叫缩小增量排序<br>2，将待排序的序列分割成若干个子序列（间隔）分别进行插入排序，当整个序列基本有序的时候再对全体进行一次插入排序<br>3，增量序列的取法：最后一步必须是1（整体插入排序）。可以取size/2或其他</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//定义间隔序列</span></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; <span class="built_in">size</span> / <span class="number">2</span>) &#123;</span><br><span class="line">		gap = <span class="number">2</span> * gap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//这里是间隔的插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= gap &amp;&amp; (arr[j] &lt; arr[j - gap]); j -= gap) &#123;</span><br><span class="line">				<span class="built_in">std</span>::swap(arr[j], arr[j - gap]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap /= <span class="number">2</span>;	<span class="comment">//更新间隔数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序动态图"><br><strong>特点：</strong><br>1，在希尔排序出现之前，计算机界普遍认为排序算法不可能突破O（n2），希尔排序是第一个突破O（n2）的算法<br>2，插入排序是稳定的排序算法，希尔排序是多次插入的过程，它是<strong>不稳定</strong>的<br>3，复杂度依然较高，只适合中小规模</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>思路：</strong><br>分治思想：先使得每个子序列有序，再将子序列两两有序合并<br>1，分解（Divide）：将n个元素对半分成两个子序列<br>2，解决（Conquer）：将两个子序列分别排序<br>3，合并（Combine）：合并两个已经排好序的子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*归并排序——递归版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_helper</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span>* help, <span class="keyword">const</span> <span class="keyword">int</span> start, <span class="keyword">const</span>  <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以下是数组分割*/</span></span><br><span class="line">	<span class="keyword">int</span> mid = ((<span class="built_in">end</span> - start) &gt;&gt; <span class="number">1</span>) + start;		<span class="comment">//找到中间点</span></span><br><span class="line">	<span class="comment">//将原数组拆分成两段</span></span><br><span class="line">	<span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">	<span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="built_in">end</span>;</span><br><span class="line">	merge_sort_recursive_helper(arr, help, start1, end1);</span><br><span class="line">	merge_sort_recursive_helper(arr, help, start2, end2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以下是排序合并*/</span></span><br><span class="line">	<span class="keyword">int</span> k = start;</span><br><span class="line">	<span class="comment">//将两段合并，直到一段用完</span></span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">		help[k++] = (arr[start1] &lt; arr[start2]) ? arr[start1++] : arr[start2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将没用完的一段直接接在末尾</span></span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1) help[k++] = arr[start1++];</span><br><span class="line">	<span class="keyword">while</span> (start2 &lt;= end2) help[k++] = arr[start2++];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将辅助数组种的元素复制到原来的数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = start; k &lt;= <span class="built_in">end</span>; ++k) &#123;</span><br><span class="line">		arr[k] = help[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span>  <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//辅助数组，用来存放排序的结果</span></span><br><span class="line">	<span class="keyword">int</span>* help = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br><span class="line">	merge_sort_recursive_helper(arr, help, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*归并排序——迭代版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_iteration</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* help = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>]();</span><br><span class="line">	<span class="keyword">int</span>* a = arr;</span><br><span class="line">	<span class="comment">//片段长度block = 1,2,4,8....</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> block = <span class="number">1</span>; block &lt; <span class="built_in">size</span>; block *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//两两遍历片段</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; <span class="built_in">size</span>; start += (block * <span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> low = start;</span><br><span class="line">			<span class="comment">//取start+block和size种的较小者，防止越界,high同理</span></span><br><span class="line">			<span class="keyword">int</span> mid = (start + block) &gt; <span class="built_in">size</span> ? <span class="built_in">size</span> : (start + block);</span><br><span class="line">			<span class="keyword">int</span> high = (start + block * <span class="number">2</span>) &gt; <span class="built_in">size</span> ? <span class="built_in">size</span> : (start + block * <span class="number">2</span>);</span><br><span class="line">			<span class="comment">//分成两段，两段的起始和结束下标</span></span><br><span class="line">			<span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">			<span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">			<span class="keyword">int</span> k = low;</span><br><span class="line">			<span class="comment">//将两段合并，直到一段用完</span></span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">				help[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将没用完的一段直接接在末尾</span></span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1) help[k++] = a[start1++];</span><br><span class="line">			<span class="keyword">while</span> (start2 &lt; end2) help[k++] = a[start2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//交换a和help指针</span></span><br><span class="line">		<span class="keyword">int</span>* temp = a;</span><br><span class="line">		a = help;</span><br><span class="line">		help = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		当size是偶数的时候，help和a最后结果指向不变</span></span><br><span class="line"><span class="comment">		当size是奇数的时候，help和a最后指向相反</span></span><br><span class="line"><span class="comment">		最终help中存储的是排好的序列，要将help中的序列复制到原来的arr中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">			help[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		help = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发散思维：</strong><br>1，虽然渐近复杂度和快排一样，但是归并排序的系数更大<br>2，对归并排序的改进：在分割成小数组的时候，改用插入排序<br><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序动态图"><br><strong>特点：</strong><br>1，归并排序是<strong>稳定</strong>的排序算法<br>2，时间复杂度小，数据量大的时候速度快，但是它有着<strong>O（n）的空间复杂度</strong>，在内存有限的时候谨慎使用</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>思路：</strong><br>1，从数组中挑选一个<strong>基准元素</strong><br>2，重新排列数组，所有比基准值小的元素都放在基准元素的前面，所有比基准大的数都放在基准元素后面<br>3，递归的将两个子序列重新排列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*迭代和递归均使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[low];	<span class="comment">//基准元素取子序列的第一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="comment">//找到一个比基准元素大的元素，和基准元素进行交换</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high;</span><br><span class="line">		arr[low] = arr[high];</span><br><span class="line">		<span class="comment">//找到一个比基准元素小的元素，和基准元素进行交换</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low;</span><br><span class="line">		arr[high] = arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//扫描结束，恢复基准元素的位置</span></span><br><span class="line">	arr[low] = pivot;</span><br><span class="line">	<span class="comment">//返回基准元素的位置</span></span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*快速排序——递归版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive_helper</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> low, <span class="keyword">const</span> <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//将数组分成两部分</span></span><br><span class="line">	<span class="keyword">int</span> pivot = quick_sort_partition(arr, low, high);</span><br><span class="line">	<span class="comment">//递归排序左右子数组</span></span><br><span class="line">	quick_sort_recursive_helper(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">	quick_sort_recursive_helper(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	quick_sort_recursive_helper(arr, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*快速排序——迭代版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_iterative</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//栈数组</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* <span class="built_in">stack</span> = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="built_in">std</span>::<span class="keyword">size_t</span>)<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//将最大最小值压入栈</span></span><br><span class="line">	<span class="built_in">stack</span>[++top] = <span class="built_in">min</span>;</span><br><span class="line">	<span class="built_in">stack</span>[++top] = <span class="built_in">max</span>;</span><br><span class="line">	<span class="comment">//开始迭代</span></span><br><span class="line">	<span class="keyword">while</span> (top &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">max</span> = <span class="built_in">stack</span>[top--];</span><br><span class="line">		<span class="built_in">min</span> = <span class="built_in">stack</span>[top--];</span><br><span class="line">		<span class="comment">//将数组分成两部分</span></span><br><span class="line">		<span class="keyword">int</span> pivot = quick_sort_partition(arr, <span class="built_in">min</span>, <span class="built_in">max</span>);</span><br><span class="line">		<span class="comment">//若基准元素左边还有数据元素</span></span><br><span class="line">		<span class="keyword">if</span> (pivot - <span class="number">1</span> &gt; <span class="built_in">min</span>) &#123;</span><br><span class="line">			<span class="built_in">stack</span>[++top] = <span class="built_in">min</span>;</span><br><span class="line">			<span class="built_in">stack</span>[++top] = pivot - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若基准元素右边还有数据元素</span></span><br><span class="line">		<span class="keyword">if</span> (pivot + <span class="number">1</span> &lt; <span class="built_in">max</span>) &#123;</span><br><span class="line">			<span class="built_in">stack</span>[++top] = pivot + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">stack</span>[++top] = <span class="built_in">max</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序动态图"></p>
<p><strong>快速排序的优化：</strong><br>为了避免最坏情况下的低效率，可以优化基准元素的选择，将每次选择最低位改成在序列中随机一个元素作为基准元素，只需要修改 quick_sort_partition函数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*迭代和递归均使用*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//基准元素取子序列的一个随机元素</span></span><br><span class="line">	<span class="keyword">int</span> index = (rand() % (high - low)) + low;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[index];	</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="comment">//找到一个比基准元素大的元素，和基准元素进行交换</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high;</span><br><span class="line">		arr[low] = arr[high];</span><br><span class="line">		<span class="comment">//找到一个比基准元素小的元素，和基准元素进行交换</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low;</span><br><span class="line">		arr[high] = arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//扫描结束，恢复基准元素的位置</span></span><br><span class="line">	arr[index] = pivot;</span><br><span class="line">	<span class="comment">//返回基准元素的位置</span></span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong><br>1，快排是<strong>不稳定</strong>的排序算法<br>2，大多数情况下表现很好，速度很快O(nlogn)。但是在<strong>最坏情况</strong>下表现一般O（n2）</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>思路：</strong><br>1，堆是树形结构的一种，可以根据待排序的元素俩构建一棵小根堆，那么小根堆的根节点就是序列中最小的元素<br>2，如果我们要获取一个升序序列，建立一个小根堆，每次输出根节点，但是这样需要开辟额外的空间（否则将造成大量元素移动），为了处理这个问题，我们可以选择建立一个大根堆，然后倒序输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_heap</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> cur, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//调整为最大堆,cur为待调整结点</span></span><br><span class="line">	<span class="comment">//cur的左孩子</span></span><br><span class="line">	<span class="keyword">int</span> child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; <span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="comment">//child + 1是当前结点cur的右孩子</span></span><br><span class="line">		<span class="comment">//如果有右孩子而且大于左孩子，则用右孩子来与cur比较，否则用左孩子</span></span><br><span class="line">		<span class="keyword">if</span> ((child + <span class="number">1</span>) &lt; <span class="built_in">size</span> &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) child++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若较大的孩子比当前结点cur大</span></span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt; arr[child]) &#123;</span><br><span class="line">			<span class="comment">//交换孩子结点和父节点</span></span><br><span class="line">			<span class="built_in">std</span>::swap(arr[cur], arr[child]);</span><br><span class="line">			<span class="comment">//此时child指向的是原来的父结点</span></span><br><span class="line">			<span class="comment">//继续判断原来的父结点是否需要继续调整</span></span><br><span class="line">			cur = child;</span><br><span class="line">			child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//待调整结点小于其左右孩子，不用调整，直接结束</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//建堆: 最后一个非叶子结点的位置是i = (size - 1) / 2，从它开始依次向上调整</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="built_in">size</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		adjust_heap(arr, i, <span class="built_in">size</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将大根堆反向输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">		adjust_heap(arr, <span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序动态图"><br><strong>特点：</strong><br>1,建堆和堆的调整开销较高，因此<strong>不适合元素数量少</strong>的时候使用<br>2，适合解决<strong>前n大的数</strong>这种问题</p>
<h2 id="线性时间非比较类"><a href="#线性时间非比较类" class="headerlink" title="线性时间非比较类"></a>线性时间非比较类</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>思路：</strong><br>前提要求：输入的数据必须是有<strong>确定范围</strong>的整数<br>1，找出待排序数组中最大的和最小的元素<br>2，统计数组中值为i的元素出现的次数，存储在help[i]<br>3，对计数数组进行累加help[i] += help[i - 1];<br>4，反向填充目标数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span> = arr[<span class="number">0</span>], <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//寻找最大值max和最小值min</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min</span> &gt; arr[i]) <span class="built_in">min</span> = arr[i];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i]) <span class="built_in">max</span> = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//count_num = 1，说明数组中的元素全部一样</span></span><br><span class="line">	<span class="keyword">int</span> count_num = <span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (count_num &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//用于计数的数组,初始元素都是0</span></span><br><span class="line">	<span class="keyword">int</span>* help = <span class="keyword">new</span> <span class="keyword">int</span>[count_num]();</span><br><span class="line">	<span class="comment">//计算数组中每个元素i出现的次数，存储到help【i】中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		help[arr[i] - <span class="built_in">min</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算数组中小于等于每个元素的个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span> + <span class="number">1</span>; i &lt;= <span class="built_in">max</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> index = i - <span class="built_in">min</span>;</span><br><span class="line">		help[i - <span class="built_in">min</span>] += help[index - <span class="number">1</span>];;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将排序结果存放在result中</span></span><br><span class="line">	<span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		res[help[arr[i] - <span class="built_in">min</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">		--help[arr[i] - <span class="built_in">min</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将res数组里的元素复制到arr数组中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		arr[i] = res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] res;</span><br><span class="line">	<span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序动态图"><br><strong>特点：</strong><br>1，计数排序是<strong>稳定</strong>的排序算法<br>2，<strong>重点：</strong>最大最小值应当容易辨别，比如排序高考成绩，即0-750之间<br>3，计数排序有着O（n）的空间复杂度</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><strong>思路：</strong><br>1，原理是将数组分散到数量有限的箱子里，然后对每个桶再排序，最后将各个桶中的数据有序的合并起来。<br>2，计数排序是桶排序的一种特殊情况，每个桶中只有一个元素<br>3，在每个桶里，可以使用其他适用于小规模的原地排序算法，这里用的是前面的插入排序和快速排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span> = arr[<span class="number">0</span>], <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//寻找最大值max和最小值min</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min</span> &gt; arr[i]) <span class="built_in">min</span> = arr[i];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">max</span> &lt; arr[i]) <span class="built_in">max</span> = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//桶的数量</span></span><br><span class="line">	<span class="keyword">int</span> bucket_num = (<span class="built_in">max</span> - <span class="built_in">min</span>) / <span class="built_in">size</span> + <span class="number">1</span>;	</span><br><span class="line">	<span class="comment">//统计每个桶里有多少个元素</span></span><br><span class="line">	<span class="keyword">int</span>* sizeof_each_bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucket_num]();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> index_bucket = (arr[i] - <span class="built_in">min</span>) / <span class="built_in">size</span>;</span><br><span class="line">		sizeof_each_bucket[index_bucket]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开辟桶空间</span></span><br><span class="line">	<span class="keyword">int</span>** bucket_arr = <span class="keyword">new</span> <span class="keyword">int</span>* [bucket_num];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_num; ++i) &#123;</span><br><span class="line">		bucket_arr[i] = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="built_in">std</span>::<span class="keyword">size_t</span>)sizeof_each_bucket[i] + <span class="number">1</span>]();</span><br><span class="line">		<span class="comment">//第一位存放该桶的size-1</span></span><br><span class="line">		bucket_arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将每个元素放入桶中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> index_bucket = (arr[i] - <span class="built_in">min</span>) / <span class="built_in">size</span>;</span><br><span class="line">		<span class="keyword">int</span> cur_bucket_size = bucket_arr[index_bucket][<span class="number">0</span>]++;</span><br><span class="line">		bucket_arr[index_bucket][cur_bucket_size] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对每个桶进行排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_num; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bucket_arr[i][<span class="number">0</span>] == <span class="number">1</span> || bucket_arr[i][<span class="number">0</span>] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (bucket_arr[i][<span class="number">0</span>] &lt; <span class="number">47</span>) &#123;</span><br><span class="line">			insertion_sort(bucket_arr[i] + <span class="number">1</span>, bucket_arr[i][<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			quick_sort_iterative(bucket_arr[i] + <span class="number">1</span>, bucket_arr[i][<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将bucket_arr中的元素复制到arr中</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_num; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; bucket_arr[i][<span class="number">0</span>]; ++j) &#123;</span><br><span class="line">			arr[index++] = bucket_arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] sizeof_each_bucket;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket_num; ++i) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] bucket_arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] bucket_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpg" alt="桶排序示意图（没找到动图）"><br><strong>特点：</strong><br>1，桶排序可用于max-min较大的情况<br>2，要求数据分布<strong>较为均匀</strong>，不然可能会集中到一个桶中，这样桶排序就失效了</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>思路：</strong><br>1，基数排序是桶排序的扩展，其基本思想是按找数位来排序（类似于有10个桶）<br>2，从低位开始，元素按数位上的数字（0-9）入桶，然后再将桶内元素收集起来（排序）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_radix</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*获取数组中的最大数位*/</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//先找到最大数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; <span class="built_in">max</span>) <span class="built_in">max</span> = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> radix = <span class="number">1</span>, temp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		temp *= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">max</span> / temp != <span class="number">0</span>) &#123;</span><br><span class="line">			radix++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> radix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*获取数字num第pos位数字*/</span></span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		temp *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num / temp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span> || <span class="built_in">size</span> &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//0-9共10个桶</span></span><br><span class="line">	<span class="keyword">int</span>** help = <span class="keyword">new</span> <span class="keyword">int</span>* [<span class="number">10</span>]();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		help[i] = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="built_in">std</span>::<span class="keyword">size_t</span>)<span class="built_in">size</span> + <span class="number">1</span>]();</span><br><span class="line">		help[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max_radix = get_max_radix(arr, <span class="built_in">size</span>);</span><br><span class="line">	<span class="comment">//第i位数排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> radix = <span class="number">1</span>; radix &lt;= max_radix; ++radix) &#123;</span><br><span class="line">		<span class="comment">//将数组中的元素，按数位分配到各个桶中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> row = get_num(arr[i], radix);</span><br><span class="line">			<span class="keyword">int</span> col = help[row][<span class="number">0</span>]++;</span><br><span class="line">			help[row][col] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从各个桶中收集元素</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; ++row) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt; help[row][<span class="number">0</span>]; ++col) &#123;</span><br><span class="line">				arr[index++] = help[row][col];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//复位，下一个数位继续用</span></span><br><span class="line">			help[row][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] help[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序动态图"><br><strong>特点：</strong><br>1，元素必须是<strong>整数</strong><br>2，可以适用于<strong>字符串排序</strong><br>3，可以适用于<strong>多条件排序</strong>的场景，比如日期排序，先排年，再排月</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="排序算法的复杂度"><br>0，没有最好的排序，只有最适合的排序<br>1，平均时间来看，快读排序效率最高，但是快速排序在最坏情况下的时间性能不如堆排序和归并排序。<br>2，在数据规模较大时归并排序时间性能较好，但使用额外空间较多<br>3，简单排序：冒泡排序，插入排序，选择排序。插入排序常常和其他排序算法结合使用</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
