<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见10种排序算法</title>
    <url>/2020/06/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>条款02：尽量以const，enum，inline替换#define</title>
    <url>/2020/05/Effective-C++/Effective-CPP-02/</url>
    <content><![CDATA[<p><strong>用编译器替换预处理器</strong></p>
<h4 id="define的问题：定义常量"><a href="#define的问题：定义常量" class="headerlink" title="define的问题：定义常量"></a>define的问题：定义常量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>1，难以追踪异常<br>2，无法限制作用域，不提供封装性</p>
<p>解决办法是：<strong>用const常量替代宏（#define）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>；</span><br></pre></td></tr></table></figure>
<p>(ps：大写名称通常用于宏)</p>
<h5 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h5><h6 id="定义常量指针"><a href="#定义常量指针" class="headerlink" title="定义常量指针"></a>定义常量指针</h6><p>常量定义通常被定义在头文件中，有必要将指针（而不是指针所指之物）声名为const<br>例如定义一个常量字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Scott Meyers"</span>;</span><br></pre></td></tr></table></figure>
<p>一种更好的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"Scott Meyers"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="定义class专属常量（限制作用域）"><a href="#定义class专属常量（限制作用域）" class="headerlink" title="定义class专属常量（限制作用域）"></a>定义class专属常量（限制作用域）</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns;  <span class="comment">//声名式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NUmTurns = <span class="number">5</span>;   <span class="comment">//定义式</span></span><br></pre></td></tr></table></figure>
<p>（ps：只要不取NumTurns的地址，则无需提供定义式，即声名时便赋予初值）<br><strong>另一种方式：使用枚举类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认识 enum hack：<br>1，更像#define：不能取enum和#define的地址，避免非必要的内存分配<br>2，模板元变成的基础技术</p>
<h4 id="define的问题：宏表达式"><a href="#define的问题：宏表达式" class="headerlink" title="define的问题：宏表达式"></a>define的问题：宏表达式</h4><p>宏表达式的样子像函数，但是由于会被替换成实际代码，行为和函数也不同，容易造成错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用a和b中的较大者为参数来调用f()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>
<p><strong>使用inline替换：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Type T&gt;      <span class="comment">//不清楚a和b的类型</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWIthMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有了const、enum、inline，降低了对预处理器（尤其是#define）的需求，但是#include仍然是必须的，#ifdef/#ifndef也用于控制编译<br><strong>请记住：</strong></p>
<ul>
<li>对于常量，最好以const对象或者enum替换#define</li>
<li>对于形似函数的宏，最好用inline函数替换#define</li>
</ul>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>常见10种排序算法</title>
    <url>/2020/06/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%8110%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="常见的排序算法可以分成两类"><a href="#常见的排序算法可以分成两类" class="headerlink" title="常见的排序算法可以分成两类"></a>常见的排序算法可以分成两类</h3><h4 id="非线性时间-比较类排序"><a href="#非线性时间-比较类排序" class="headerlink" title="非线性时间 比较类排序"></a>非线性时间 比较类排序</h4><p>1，通过<strong>比较</strong>来决定元素间的相对次序<br>2，其时间复杂度不能突破O(nlogn)</p>
<h4 id="线性时间-非比较类排序"><a href="#线性时间-非比较类排序" class="headerlink" title="线性时间 非比较类排序"></a>线性时间 非比较类排序</h4><p>1，不通过比较来决定元素间的相对次序<br>2，可以突破基于比较排序的时间下界，以线性时间运行、</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>思路：</strong><br>外层循环从1到n-1（一共n-1趟），内层循环从当前外层元素的下一个位置开始，依次和下一个元素比较，出现逆序就交换，把相邻元素的较小者交换到前面。看起来就像每趟最大的元素依次交换，移动到最后（冒泡）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外层循环控制排序趟数，共n-1趟</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="comment">//内层循环控制每一趟排序次数</span></span><br><span class="line">		<span class="comment">//最末尾的i个已经被排好了,所以j的范围是0到size-1-i</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span> - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序动态图"></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>思路：</strong><br>在未排序序列种找到最小者，存放到排序序列的末尾位置，以此类推，直到所有的元素均排序完毕</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="comment">//已排序序列0到i，未排序序列i到size-1</span></span><br><span class="line">		<span class="comment">//找到未排序序列的最小元素arr[min]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">size</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123;</span><br><span class="line">				<span class="built_in">min</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将找到的最小元素放到已排序序列的末尾</span></span><br><span class="line">		<span class="built_in">std</span>::swap(arr[<span class="built_in">min</span>], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序动态图"></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>思路：</strong><br>对于未排序序列中的一个元素，在已排序序列种从后向前扫描，找到相应的位置插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//一开始的已排序序列0，未排序序列1到n-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">		<span class="comment">//当前未排序序列的一个元素</span></span><br><span class="line">		<span class="keyword">int</span> key = arr[i];</span><br><span class="line">		<span class="comment">//已排序序列的末尾位置</span></span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			--j;<span class="comment">//向前移动</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入到相应位置</span></span><br><span class="line">		arr[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序动态图"></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>思路：</strong><br>1，希尔排序是插入排序的一种高效实现，也叫缩小增量排序<br>2，将待排序的序列分割成若干个子序列（间隔）分别进行插入排序，当整个序列基本有序的时候再对全体进行一次插入排序<br>3，增量序列的取法：最后一步必须是1（整体插入排序）。可以取size/2或其他</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//定义间隔序列</span></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; <span class="built_in">size</span> / <span class="number">2</span>) &#123;</span><br><span class="line">		gap = <span class="number">2</span> * gap;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//这里是间隔的插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= gap &amp;&amp; (arr[j] &lt; arr[j - gap]); j -= gap) &#123;</span><br><span class="line">				<span class="built_in">std</span>::swap(arr[j], arr[j - gap]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap /= <span class="number">2</span>;	<span class="comment">//更新间隔数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序动态图"></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>思路：</strong><br>分治思想：先使得每个子序列有序，再将子序列两两有序合并<br>1，分解（Divide）：将n个元素对半分成两个子序列<br>2，解决（Conquer）：将两个子序列分别排序<br>3，合并（COmbine）：合并两个已经排好序的子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*归并排序——递归版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive_helper</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span>* help, <span class="keyword">const</span>  <span class="keyword">int</span> start, <span class="keyword">const</span>  <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以下是数组分割*/</span></span><br><span class="line">	<span class="keyword">int</span> mid = ((<span class="built_in">end</span> - start) &gt;&gt; <span class="number">1</span>) + start;		<span class="comment">//找到中间点</span></span><br><span class="line">	<span class="comment">//将原数组拆分成两段</span></span><br><span class="line">	<span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">	<span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="built_in">end</span>;</span><br><span class="line">	merge_sort_recursive_helper(arr, help, start1, end1);</span><br><span class="line">	merge_sort_recursive_helper(arr, help, start2, end2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以下是排序合并*/</span></span><br><span class="line">	<span class="keyword">int</span> k = start;</span><br><span class="line">	<span class="comment">//将两段合并，直到一段用完</span></span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">		help[k++] = (arr[start1] &lt; arr[start2]) ? arr[start1++] : arr[start2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将没用完的一段直接接在末尾</span></span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1) help[k++] = arr[start1++];</span><br><span class="line">	<span class="keyword">while</span> (start2 &lt;= end2) help[k++] = arr[start2++];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将辅助数组种的元素复制到原来的数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = start; k &lt;= <span class="built_in">end</span>; ++k) &#123;</span><br><span class="line">		arr[k] = help[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span>  <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//辅助数组，用来存放排序的结果</span></span><br><span class="line">	<span class="keyword">int</span>* help = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br><span class="line">	merge_sort_recursive_helper(arr, help, <span class="number">0</span>, <span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*归并排序——迭代版本*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_iteration</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">const</span>  <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* help = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>]();</span><br><span class="line">	<span class="keyword">int</span>* a = arr;</span><br><span class="line">	<span class="comment">//片段长度block = 1,2,4,8....</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> block = <span class="number">1</span>; block &lt; <span class="built_in">size</span>; block *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//两两遍历片段</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; <span class="built_in">size</span>; start += (block * <span class="number">2</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> low = start;</span><br><span class="line">			<span class="comment">//取start+block和size种的较小者，防止越界,high同理</span></span><br><span class="line">			<span class="keyword">int</span> mid = (start + block) &gt; <span class="built_in">size</span> ? <span class="built_in">size</span> : (start + block);</span><br><span class="line">			<span class="keyword">int</span> high = (start + block * <span class="number">2</span>) &gt; <span class="built_in">size</span> ? <span class="built_in">size</span> : (start + block * <span class="number">2</span>);</span><br><span class="line">			<span class="comment">//分成两段，两段的起始和结束下标</span></span><br><span class="line">			<span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">			<span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">			<span class="keyword">int</span> k = low;</span><br><span class="line">			<span class="comment">//将两段合并，直到一段用完</span></span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">				help[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将没用完的一段直接接在末尾</span></span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1) help[k++] = a[start1++];</span><br><span class="line">			<span class="keyword">while</span> (start2 &lt; end2) help[k++] = a[start2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//交换a和help指针</span></span><br><span class="line">		<span class="keyword">int</span>* temp = a;</span><br><span class="line">		a = help;</span><br><span class="line">		help = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		当size是偶数的时候，help和a最后结果指向不变</span></span><br><span class="line"><span class="comment">		当size是奇数的时候，help和a最后指向相反</span></span><br><span class="line"><span class="comment">		最终help中存储的是排好的序列，要将help中的序列复制到原来的arr中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">			help[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		help = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/Morakito/Blog-Images/raw/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序动态图"></p>
]]></content>
      <categories>
        <category>-算法</category>
      </categories>
      <tags>
        <tag>-排序算法 -算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库003</title>
    <url>/2020/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93003/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>条款03：尽可能使用const</title>
    <url>/2020/06/Effective-C++/Effective-CPP-03/</url>
    <content><![CDATA[<h3 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h3><p>1，告诉编译器和其他程序员某值应该保持不变<br>2，会获得编译器的帮助提示</p>
<h3 id="const的语法：常量声名"><a href="#const的语法：常量声名" class="headerlink" title="const的语法：常量声名"></a>const的语法：常量声名</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>1，如果const出现在*****的左边，表示被指物是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;   <span class="comment">//不可以修改*p，可以修改p</span></span><br></pre></td></tr></table></figure>
<p>2，如果const出现在*****的右边，表示指针自身是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;   <span class="comment">//可以修改*p，不可以修改p</span></span><br></pre></td></tr></table></figure>
<p>3，如果const出现在*****两边，表示被指物和指针都是常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;   <span class="comment">//不可以修改*p，不可以修改p</span></span><br></pre></td></tr></table></figure>
<h3 id="const的语法：函数声名"><a href="#const的语法：函数声名" class="headerlink" title="const的语法：函数声名"></a>const的语法：函数声名</h3><p>在一个函数声名式中，const可以和函数返回值，参数，函数自身（成员函数）发生关系</p>
<h4 id="作用于参数"><a href="#作用于参数" class="headerlink" title="作用于参数"></a>作用于参数</h4><p>1，const参数类似于local const对象，参数不可修改<br>2，除非需要改动参数，否则应该声名为const</p>
<h4 id="作用于返回值"><a href="#作用于返回值" class="headerlink" title="作用于返回值"></a>作用于返回值</h4><p>预防“没有意义的赋值操作”，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">(a * b) = c;    <span class="comment">//在a * b的结果上调用operator=</span></span><br></pre></td></tr></table></figure>
<h4 id="作用于成员函数（const成员函数）"><a href="#作用于成员函数（const成员函数）" class="headerlink" title="作用于成员函数（const成员函数）"></a>作用于成员函数（const成员函数）</h4><p>目的是确认改成员函数可作用于const对象身上</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款01：视C++为一个语言联邦</title>
    <url>/2020/05/Effective-C++/Effective-CPP-01/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天的C++已经是个多重泛型编程语言，支持面向过程、面向对象、函数编程、泛型、元编程等。可以将C++看成一个由相关语言组成的联邦而非单一语言。</p>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>1，C++以C语言为基础，区块（blocks）、语句（statements）、预处理器（preprocesser）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等都来自于C语言。<br>2，但是C语言没有模板（templates），没有异常（exceptions），没有重载（overloading）等概念。</p>
<h4 id="Object——Oriented-C"><a href="#Object——Oriented-C" class="headerlink" title="Object——Oriented C++"></a>Object——Oriented C++</h4><p>即C++的面向对象部分，C with Classes的诉求：类（classes）、封装（encapsulation）、继承（inheritance）、多态（polymorphism）、虚函数（virtual动态绑定）。</p>
<h4 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h4><p>C++的泛型编程部分。带来了新的编程范型，template metaprogramming（TMP，模板元编程）</p>
<h4 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h4><p>STL是标准模板库，template库。内置容器（containers）、迭代器（iterators）、算法（algorithm）、函数对象（function objects）</p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库002-关系模型</title>
    <url>/2020/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93002/</url>
    <content><![CDATA[<h3 id="关系数据库的结构"><a href="#关系数据库的结构" class="headerlink" title="关系数据库的结构"></a>关系数据库的结构</h3><p>关系数据库由<strong>表（table）</strong>的集合构成，每个表有<strong>唯一的名字</strong>。</p>
<h4 id="关系模型术语："><a href="#关系模型术语：" class="headerlink" title="关系模型术语："></a>关系模型术语：</h4><p>1，<strong>关系</strong>（relation）用来指代表<br>2，<strong>元组</strong>（tuple）用来指代行<br>3，<strong>属性</strong>（attribute）指代表中的列</p>
<h4 id="属性的域"><a href="#属性的域" class="headerlink" title="属性的域"></a>属性的域</h4><p>1，对于关系的每个属性，都存在一个允许取值的集合，叫做属性的域<br>2，域是<strong>原子</strong>的，即域中元素都是不可再分的<br>3，<strong>空值（null）</strong>代表值未知或者不存在<br>（ps：应尽量避免使用空值）</p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>一个元组的属性值必须能够唯一区分元组：一个关系中没有两个元组所有的属性值都相同（两行完全一样）</p>
<h4 id="超码（super-key）"><a href="#超码（super-key）" class="headerlink" title="超码（super key）"></a>超码（super key）</h4><p>1，<strong>一个</strong>或者<strong>多个</strong>属性<br>2，在一个关系中唯一标识一个元组：<strong>区分一个表中的不同行</strong></p>
<h4 id="候选码（candidate-key）"><a href="#候选码（candidate-key）" class="headerlink" title="候选码（candidate key）"></a>候选码（candidate key）</h4><p><strong>最小超码</strong>：任意真子集都不能成为超码</p>
<pre><code>例如：
{ID}和{name，dept_name}都是候选码，
但是{ID，name}却不是候选码，
因为单独的属性ID已经是候选码了。</code></pre><h4 id="主码（primary-key）"><a href="#主码（primary-key）" class="headerlink" title="主码（primary key）"></a>主码（primary key）</h4><p>1，被选中的候选码，用来区分表中不同的的行（<strong>唯一标识符</strong>）<br>2，<strong>码</strong>是整个表的一种属性，而不是某一行的属性<br>3，一个表中的任意两行都不能在码属性上具有相同的值（唯一）<br>3，主码应选择那些值从不或者极少变化的属性</p>
<h4 id="外码（foreign-key）"><a href="#外码（foreign-key）" class="headerlink" title="外码（foreign key）"></a>外码（foreign key）</h4><p>1，关系模式：逻辑设计，类似于类型定义（表的格式）<br>2，关系模式r1在属性中包含另一个关系模式r2的<strong>主码</strong>，这个属性在r1上称作参照r2的<strong>外码</strong><br>关系r1叫做<strong>外码依赖的参照关系</strong>，关系r2叫做<strong>被参照关系</strong></p>
<h3 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h3><p>实际使用的查询语言既包括过程化的成分，又包括非过程化的成分</p>
<h4 id="过程化语言"><a href="#过程化语言" class="headerlink" title="过程化语言"></a>过程化语言</h4><p>用户指导数据库进行一系列操作<br>如：关系代数</p>
<h4 id="非过程化语言"><a href="#非过程化语言" class="headerlink" title="非过程化语言"></a>非过程化语言</h4><p>用户只描述所需信息，不给出获取信息的具体过程<br>如元组关系演算和域关系演算</p>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><h4 id="选择-δ"><a href="#选择-δ" class="headerlink" title="选择 δ"></a>选择 δ</h4><p>从一个表中选出满足特定要求的行，其结果是一张新表</p>
<h4 id="投影-Π"><a href="#投影-Π" class="headerlink" title="投影 Π"></a>投影 Π</h4><p>从一个表中选择特定的属性（列），其结果是一张新表</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1，自然连接<br>两个表中的属性匹配<br>2，笛卡尔积<br>输出所有元组（行）对</p>
<center>关系代数的运算举例</center> 

<p><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/002-1.png" alt="关系代数的运算举例"></p>
<h3 id="术语回顾"><a href="#术语回顾" class="headerlink" title="术语回顾"></a>术语回顾</h3><blockquote>
<p>表<br>关系（表）<br>元组（行）<br>属性（列）<br>空值（null）<br>域<br>原子域</p>
</blockquote>
<blockquote>
<p>数据库模式<br>数据库实例<br>关系模式<br>关系实例</p>
</blockquote>
<blockquote>
<p>码<br>超码<br>候选码<br>主码<br>外码<br>参照关系<br>被参照关系</p>
</blockquote>
<blockquote>
<p>关系代数<br>选择（选择行）<br>投影（选择列）<br>自然连接（属性匹配）<br>笛卡尔积（所有行对）<br>集合运算</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库001-数据库系统概述</title>
    <url>/2020/05/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93001/</url>
    <content><![CDATA[<h2 id="1-1数据库系统概述"><a href="#1-1数据库系统概述" class="headerlink" title="1.1数据库系统概述"></a>1.1数据库系统概述</h2><h3 id="1-1-1数据库系统的四个基本概念"><a href="#1-1-1数据库系统的四个基本概念" class="headerlink" title="1.1.1数据库系统的四个基本概念"></a>1.1.1数据库系统的四个基本概念</h3><h4 id="数据（date）"><a href="#数据（date）" class="headerlink" title="数据（date）"></a>数据（date）</h4><p>1，数据是数据库中存储的<strong>基本对象</strong><br>2，描述事物的符号记录称为数据<br>3，现代计算机系统中的数据的概念是广义的。包括文本，图像，视频等<br>4，数据与其语义是不可分的，数据的解释是指对数据含义的说明<br>5，<strong>记录</strong>是计算机系统中表示和存储数据的一种格式或方法</p>
<h4 id="数据库（DataBase，DB）"><a href="#数据库（DataBase，DB）" class="headerlink" title="数据库（DataBase，DB）"></a>数据库（DataBase，DB）</h4><p>1，数据库是长期存储在计算机内、有组织、可共享的大量数据的集合。<br>2，数据库中的数据按一定的数据模型组织、描述和存储，具有<strong>较小的冗余度</strong>，<strong>较高的数据独立性</strong>和<strong>易扩展性</strong>，并可为各种用户共享<br>3，数据库数据的特点：<strong>永久存储、有组织、可共享</strong></p>
<h4 id="数据库管理系统（DataBase-Management-System，DBMS）"><a href="#数据库管理系统（DataBase-Management-System，DBMS）" class="headerlink" title="数据库管理系统（DataBase Management System，DBMS）"></a>数据库管理系统（DataBase Management System，DBMS）</h4><p>1，DBMS解决的问题：如何科学地<strong>组织</strong>和<strong>存储</strong>数据，如何高效地<strong>获取</strong>和<strong>维护</strong>数据<br>2，DBMS是位于<strong>用户和操作系统之间</strong>地一层数据管理软件。<br>3，DBMS和操作系统一样是<strong>计算机的基础软件</strong>，是一个大型复杂的软件系统<br>4，主要功能：</p>
<ol>
<li>数据定义功能：<blockquote>
<p>(1) DBMS提供<strong>数据定义语言</strong>（Data Definition Language，<strong>DDL</strong>）。<br>(2) 用户通过DDL可对数据库中的数据对象的组成和结构进行定义。</p>
</blockquote>
</li>
<li>数据组织、存储和管理：<blockquote>
<p>(1) 确定数据的文件结构和存取方式，实现数据之间的联系。<br>(2) <strong>基本目标是提高存储利用率和方便存取</strong>。<br>(3) 提供多种存取方法：索引查找，hash查找，顺序查找等。</p>
</blockquote>
</li>
<li>数据操纵功能：<blockquote>
<p>(1) DBMS提供<strong>数据库操纵语言</strong>（Data Manipulation Language，<strong>DML</strong>）<br>(2) 用户通过DML来操纵数据，增删改查</p>
</blockquote>
</li>
<li>数据库的事务管理和运行管理：<blockquote>
<p>(1) 数据库的建立，运用和维护由DBMS统一管理和控制<br>(2) 保证事务的正确运行，保证数据的安全性、完整性，<strong>处理高并发</strong>，故障后的<strong>系统恢复</strong></p>
</blockquote>
</li>
<li>数据库的建立和维护功能：<blockquote>
<p>(1) 数据库初始数据的输入、转换<br>(2) 数据库的转储、恢复功能<br>(3) 数据库的重组织功能和性能监视、分析<br>(4) 这些功能通常由一些实用程序或管理功能实现</p>
</blockquote>
</li>
<li>其他功能：<blockquote>
<p>(1) 和其他软件的<strong>通信功能</strong><br>(2) 数据库系统之间或文件系统的<strong>数据转换</strong>功能<br>(3) 异构数据库<strong>互访和互操作</strong>功能</p>
</blockquote>
<h4 id="数据库系统（DataBase-System，DBS）"><a href="#数据库系统（DataBase-System，DBS）" class="headerlink" title="数据库系统（DataBase System，DBS）"></a>数据库系统（DataBase System，DBS）</h4>1，由数据库、数据库管理系统（DBMS），数据库管理员组成<br>2，用于存储、管理、处理和维护数据的系统<br><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/001-1.png" alt="数据库系统结构"><h3 id="1-1-2-数据库管理技术的产生和发展"><a href="#1-1-2-数据库管理技术的产生和发展" class="headerlink" title="1.1.2 数据库管理技术的产生和发展"></a>1.1.2 数据库管理技术的产生和发展</h3>1，人工管理阶段<br><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/001-2.png" alt=""><br>2，文件系统阶段<br><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/001-3.png" alt=""><center>数据管理三个阶段的比较</center> 

</li>
</ol>
<p><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/001-4.png" alt=""></p>
<h3 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a>1.1.3 数据库系统的特点</h3><p>1，整体数据结构化</p>
<blockquote>
<p>数据库的主要特征，是<strong>数据库和文件系统的本质区别</strong><br>“整体”结构化：<br>数据库中的数据不仅仅针对一个应用<br>不仅仅数据内部是结构化的，而是整体是结构化的，数据之间是有联系的</p>
</blockquote>
<p>2，数据的<strong>共享性高</strong>、<strong>冗余度低</strong>、<strong>易扩充</strong></p>
<p>3，数据独立性高</p>
<blockquote>
<p>（1），物理独立性<br>（2），逻辑独立性<br>（3），由DBMS的二级映像来保证</p>
</blockquote>
<p>4，数据由DBMS统一管理</p>
<blockquote>
<p>数据安全性保护<br>数据完整性检查<br>并发控制<br>数据库恢复</p>
</blockquote>
<center>应用程序和数据之间的对应关系</center> 

<p><img src="https://github.com/Morakito/Blog-Images/raw/DataBase/001-5.png" alt=""></p>
<h3 id="1-1小结"><a href="#1-1小结" class="headerlink" title="1.1小结"></a>1.1小结</h3><p>1，数据库是长期存储在计算机内有组织、大量、共享的<strong>数据集合</strong>。它可以供各种用户<strong>共享</strong>，具有<strong>最小冗余度</strong>和<strong>较高的数据独立性</strong>。<br>2，数据库管理系统在数据库建立、运用和维护时对数据库进行统一的控制，以保证<strong>数据的完整性和安全性</strong>，并在多用户同时使用数据库时进行<strong>并发控制</strong>，在发生故障后对数据库进行<strong>恢复</strong>。<br>3，数据库的出现使信息系统从以<strong>加工数据的程序为中心</strong>转向围绕<strong>共享的数据库为中心</strong>的新阶段。便于数据的集中管理，简化应用程序的研制和维护，提高了数据的利用率和相容性。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客实用技巧</title>
    <url>/2020/05/%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="Hexo免密部署到Github"><a href="#Hexo免密部署到Github" class="headerlink" title="Hexo免密部署到Github"></a>Hexo免密部署到Github</h3><p>1，新建系统环境变量</p>
<pre><code>Home
%USERPROFILE%</code></pre><p>2，在用户目录(C:\Users\username)下新建_netrc.txt文件，在文件中输入：</p>
<pre><code>machine github.com
login username
password password</code></pre><h3 id="添加分类功能"><a href="#添加分类功能" class="headerlink" title="添加分类功能"></a>添加分类功能</h3><p>1，在博客的根目录下执行以下命令</p>
<pre><code>hexo new page categories</code></pre><p>该命令会在source文件夹下生成一个categories文件夹，categories文件夹下会有index.md这个文件。<br>2，在index.md下添加type: categories，添加后：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这里的title是HTML页面的title，可修改成自己想要的<br>3，在编辑新的markdown文件时，需要给文章添加categories属性，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>（ps：一篇文章只会有一个分类，默认是第一个）</p>
<h3 id="添加标签功能"><a href="#添加标签功能" class="headerlink" title="添加标签功能"></a>添加标签功能</h3><p>1，在博客的根目录下执行以下命令</p>
<pre><code>hexo new page tags</code></pre><p>该命令会在source文件夹下生成一个tags文件夹，tags文件夹下会有index.md这个文件。<br>2，在index.md下添加type: tags，添加后：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>3，在编辑新的markdown文件时，需要给文章添加tags属性，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">            - </span>Hexo</span><br><span class="line">tags：</span><br><span class="line"><span class="bullet">            - </span>博客技巧</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>（ps：一篇文章可以有多个标签）</p>
<h3 id="更改URL链接"><a href="#更改URL链接" class="headerlink" title="更改URL链接"></a>更改URL链接</h3>]]></content>
      <categories>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
